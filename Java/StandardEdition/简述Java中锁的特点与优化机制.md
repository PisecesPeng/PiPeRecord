## 简述Java中锁的特点与优化机制

- [简述Java中锁的特点与优化机制](#简述java中锁的特点与优化机制)
  - [锁消除](#锁消除)
  - [锁粗化](#锁粗化)
  - [自旋锁和自适应锁](#自旋锁和自适应锁)
  - [偏向锁](#偏向锁)
    - [偏向锁的竞争、升级与撤销](#偏向锁的竞争升级与撤销)
  - [轻量级锁](#轻量级锁)
    - [轻量级锁的竞争、升级](#轻量级锁的竞争升级)
  - [重量级锁](#重量级锁)

首先, 先看看偏向锁、轻量级锁、重量级锁之间的简单比较  

| 锁 | 优点 | 缺点 | 适用场景 |
| :---: | :---: | :---: | :---: |
| 偏向锁 | 加锁和解锁不需要额外的消耗,和执行非同步方法比仅存在纳秒级的差距. | 如果线程间存在锁竞争,会带来额外的锁撤销的消耗. | 适用于只有一个线程访问同步块场景. |
| 轻量级锁 | 竞争的线程不会阻塞,提高了程序的响应速度. | 如果始终得不到锁竞争的线程,使用自旋会消耗CPU. | 追求响应时间, 同步块执行速度非常快. |
| 重量级锁 | 线程竞争不使用自旋,不会消耗CPU. | 线程阻塞,响应时间缓慢 | 追求吞吐量.同步块执行速度较长. |


其实, 在Java中锁的常见说法不仅仅只有上面三种, 还包括:  
> **锁消除**、**锁粗化**、**自旋锁**、**自适应锁**、**偏向锁**、**轻量级锁**和**重量级锁**.  

锁的状态从低到高依次为**无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁**,  
`ps. 升级的过程就是从低到高, 降级在一定条件也是有可能发生的.`  

下面让我来一一简述:  

### 锁消除

**锁消除**是发生在**编译器级别**的一种锁优化方式,  
指的是JVM检测到一些同步的代码块, 且不存在数据竞争的场景, 也就是不需要加锁干预, 就会进行锁消除.  
那么什么情况下, 才算是不存在数据竞争(不需要加锁)呢？  
比如, `StringBuffer`的`.append()`方法使用了`synchronized`关键字来进行线程安全的保护.  
但是, 如果仅在线程内部把`StringBuffer`的对象当作一个局部变量来使用, 其实就不会发生所谓的线程不安全的情况.  
那么此时, 如果Java是以`Server模式`启动的, 且已经开启了`逃逸分析`的配置, 那么编译器就会将这段代码优化, 即锁消除.  
`ps. Java有Server模式和Client模式(java -version查看), 简单来说就是前者比后者开启了更多优化.`  
`ps. 简单来说, 逃逸分析可以分析新创建对象的使用范围, 并决定是否在Java堆上分配内存的一项优化技术逃逸, 分析的主要优化方式有锁消除、标量替换和栈上分配, 这里就不展开说了.`  

### 锁粗化

锁粗化指的是有一块代码对同一个锁高频的操作(请求、同步、释放等), Java就会把锁的同步范围扩展到整个操作序列之外.  
在Java中, 为了保证多线程间的有效并发, 会使得每个线程持有锁的时间尽可能短, 但是锁本身的同步、释放等操作还是会带来一定的性能损耗的.  
那么什么情况下, Java会帮我们优化这类型的代码呢？  
比如,  
连续使用两个`synchronized(lock){}`代码块, 且锁的对象是相同的;   
将循环内部的代码全部使用`synchronized(lock){}`代码块包裹;  
以上两种情况, 都会使**锁粗化**,  
两个`synchronized(lock){}`代码块将会合并成一个`synchronized(lock){}`代码块;  
`synchronized(lock){}`代码块将会直接在循环外部将其包裹;  

### 自旋锁和自适应锁

> **1.自旋锁**:  
> 是为了解决大部分时候, 锁被占有的时间很短, 变量的锁定时间也很短, 所以没必要挂起线程,  
> 然后用户态和内核态的来回切换上下文, 从而影响性能.  
> 概念上就是让线程执行一个循环, 防止从用户态转入内核态.(自旋默认次数是10次)  
> **2.自适应锁**:  
> 自适应锁就是自适应的自旋锁, 只是自旋的时间不固定, 而是由前一次在同一个锁上的自旋时间和锁的持有者状态度来决定.  

### 偏向锁

**偏向锁**指的是线程访问同步块获取到锁时,  
**对象头**的`Mark Word`会被记录在栈帧的锁记录中,  
**当前线程ID**会在对象头的`Mark Word`中储存, 之后若同一个线程再次进入到同步块时,  
只需要判断`Mark Word`的**线程ID**与**当前线程ID**是否相等, 若相等则直接获取锁.  
也就是说, 偏向锁能够在没有实际竞争的情况下, 连CAS都不需要就能够获取锁.  
这样减少了无竞争且只有一个线程使用锁的情况下, 使用轻量级锁产生的性能消耗.  
`ps. 偏向锁在初始化时需要一次CAS.`  

#### 偏向锁的竞争、升级与撤销

前面说到, 偏向锁是在特定情况下, 减少性能消耗而出现的.  
但是, 偏向锁是没有自旋锁优化的, 因为如果存在其他线程申请锁, 那么就破坏了偏向锁的假定情况, 偏向锁也会很快升级为轻量级锁.  
> 大概流程是: 
 
> 1. 有线程来竞争**偏向锁**, 那么先判断对象头的`Mark Word`的**线程ID**是否与**当前线程ID**是否一致,  
> 一致则继续拥有锁(流程结束), 不一致则说明发生了竞争;  

> 2. 再使用**CAS操作**去替换对象头的`Mark Word`的**线程ID**, 如果替换成功则获得偏向锁(流程结束), 不成功则开始准备**撤销偏向锁**;  

> 3. 先检查拥有偏向锁的线程是否存活:  
>> 3.1. 如果已**不存活**, 那么将对象头设置为**无锁状态**(释放锁), 使得所有线程再去竞争偏向锁;  
>> 3.2. 如果拥有偏向锁的线程还**存活**,  
>> 那么在原持有偏向锁的线程到达**安全点**时暂停, 并判断原持有偏向锁的线程是否还需要偏向锁:  
>>> 3.2.1 不需要则对象头设置为**无锁状态**(释放锁), 使得所有线程再去竞争偏向锁;  
>>> 3.2.2 若是原持有偏向锁的线程还需要偏向锁, 则升级为轻量锁(向该栈帧中分配锁记录空间, 并将对象头的`Mark Word`指向这一空间, 将对象头设置为轻量级锁状态), 从安全点继续执行代码;  

> 4. 原线程升级为了轻量级锁后, 其他线程需要再去竞争轻量级锁;  

`ps. 在以上我们不难发现偏向锁的一大缺点, 就是存在竞争锁后, 偏向锁很容易就会升级为轻量级锁.`  

### 轻量级锁

**轻量级锁**也是一种多线程的优化, 它通过**CAS操作**来避免进入开销较大的互斥操作.  
其本质是多个线程交替使用锁(允许短时间的锁竞争).  
轻量级锁的竞争主要是通过CAS操作来替换**对象头**的`Mark Word`, 如果成功则获得锁, 失败则会升级为重量级锁,  
下面会详细说明.  
`ps. 竞争锁时, 轻量级锁会通过CAS操作去替换锁, 而偏向锁是假设无竞争, 其连CAS操作都不执行.`  

#### 轻量级锁的竞争、升级

**轻量级锁**的是通过一定的**自旋**来降低线程切换的成本, 但是如果锁竞争激烈, 那么就需要依赖于**重量级锁**.  
> 大概流程是:  
> 1. 有线程来竞争**轻量级锁**, 使用**CAS操作**去将对象头的`Mark Word`中的**锁记录指针**指向**当前线程锁记录**;  
> 2. 如果CAS操作替换成功, 则表示未发生竞争, 获得轻量级锁;  
> 3. 如果CAS操作替换失败, 则采用**自旋方式**再次(多次)尝试;  
> 3.1. 自旋获取锁成功, 获取轻量级锁;  
> 3.2. 自旋获取锁失败, 就是发生了锁竞争(不适合继续使用轻量级锁), 升级为**重量级锁**;  

`ps. 轻量级锁升级时, 对象头的Mark Word会通过CAS操作尝试更新一个数据结构的指针, 这个数据结构中包含了指向操作系统的互斥量(mutex)和条件变量(condition variable)的指针.`

### 重量级锁

**重量级锁**的成本非常高,  
其依赖于操作系统的**互斥量(mutex)**实现, 该操作会导致进程从**用户态**与内核态之间的切换、**线程阻塞**造成的线程切换等.  
被锁对象的重量级锁的指针指向的是**monitor对象**(也称为管程或监视器锁)的起始地址.  
每个对象都存在一个monitor与之关联, **monitor对象**存在于每个Java对象的对象头中(储存的指针指向),  
**synchronized锁**便是通过这种方式获取锁的, 也就是为什么Java中任意对象都可以作为锁的原因,  
同时也是**notify/notifyAll/wait**等方法存在于顶级对象**Object**中的原因.  
`ps. monitor等概念, 可详细去查对象结构相关内容.`  


<br><br><br><br><br>

本文参考文章: 
[https://mp.weixin.qq.com/s/AtVJfYED_EWQ3855yfF-0g](https://mp.weixin.qq.com/s/AtVJfYED_EWQ3855yfF-0g)
[https://blog.csdn.net/qq_26222859/article/details/80546917](https://blog.csdn.net/qq_26222859/article/details/80546917)
[https://www.cnblogs.com/javastack/p/11023044.html](https://www.cnblogs.com/javastack/p/11023044.html)
[https://www.jianshu.com/p/36eedeb3f912](https://www.jianshu.com/p/36eedeb3f912)
[https://blog.csdn.net/weixin_34072458/article/details/92736403](https://blog.csdn.net/weixin_34072458/article/details/92736403)
[http://f.dataguru.cn/forum.php?mod=viewthread&action=printable&tid=590471](http://f.dataguru.cn/forum.php?mod=viewthread&action=printable&tid=590471)
[https://www.cnblogs.com/charlesblc/p/5994162.html](https://www.cnblogs.com/charlesblc/p/5994162.html)
[https://www.cnblogs.com/deltadeblog/p/9559035.html](https://www.cnblogs.com/deltadeblog/p/9559035.html)
[https://blog.csdn.net/lengxiao1993/article/details/81568130](https://blog.csdn.net/lengxiao1993/article/details/81568130)
[https://www.cnblogs.com/rookiejava/p/12081126.html](https://www.cnblogs.com/rookiejava/p/12081126.html)
